change log

####
In progress:

version ham_data_collection_v0.14


	- Method to wirelessly move data from the pico to a computer or nas.  The reason for this is
		is the pico w does not have much memory so it easily fill up and choke on itself.

		There are a couple possible ideas right now.

		1) I have a mysql server running on the nas, work to get a wireless connection and write the data
        2) wirelessly copy data to a file on the nas, with something built in here to save data locally if the nas
			is not available.  Look at the weather station app to get some help with it.
		3) wirelessly copy data to a computer with something built in here to save data locally if the computer is
			not available.  Look at the weather station app to get some help with it.
		4) the second option but with usb connection to the computer, like the weather app does.  wireless
			is the prefered method.
		5) use a 3rd party product to collect, colate and have gages, charts and more.  could be better than writing my own for now.
		6) Investigating the application 'Highcarts' that the weather app uses for it's dashboards.

	- ensure a restart of the pico starts the application directly (change the name of the file to 'main')
	
	- rotation of data files :
		# once a week - daily to weekly
		# once a month - weekly to monthly
		# once a year - monthly to yearly
		## If using the database server, this probably is not necessary.
		
	- clear out unused variables and clean up their designations (global and such)

	- periodic NTP time synch is needs to be fixed.
	
	- review the display configuration definition.  When sending data to the display, the variables are not defined when the 
	  other display definitions are called.
	
####

Version control

## v0.14 ##

	- 

## v0.13 ##

	- updating the structure of the program to group similar functions, clean up the main loop and make it generally easier to read.
		- moved the display update function right under the display initialization function and both under the setting of the display variables.
		- noticed that 'setDisplayConfiguration' definition did not have any of the actions indented so they were loading without being called.
			- I tried to use them as a definition and it did not work, possible due to all of the variables set in it. have put in a placeholder 
			  for the definition so it can be investigted further later.
		- have read that it is not so good to put a definition call unter a while True loop.  Will leave the calculations,end of 
		  session and end of day checks under the while True loop after the Main definition.
	- what is working is working.  Saving this one as good place to come back to while experimenting with the data export.

## v0.12 ##

	- fixes on the end of day check.  Working better now
	- cleaned up some variables that are no longer required
	- made a mess of periodically resetting the NTP time, removed the code but may have missed some or accidentally removed others.

## v0.11 ##
	- 'distanceRunInDay' has been fixed.  Set new variable specifically for the display 'distanceRunInDayDisplay'.  
		When in session and datapoints are being calculated, I make distanceRunInDayDisplay = distanceRunInDay + distanceRunInSession so not 
		creating an exponential addition error as before and it keeps the distanceRunDay unchanged allowing me to add the distance in session 
		each time and the distance for the display up-to-date where previously I did not update it until the end of a session forcing the viewer to 
		add the distance today with the distance per session while in a session.  In the end of a session, I update the distance today 
		with the previous session time so it is ready for the next session.
		
	- updated the time between sessions from 2500 ms to 1500 ms but it was too short so for now it is at 2000 ms.
	
	- Removed this if statement
	
			if reed1TriggerTimeDifference == 0:
				reed1TriggerTimeDifference = 1
				
		and replaced it with:
		
			try:
				speedMetersPerSecond = builtins.round((wheelCircumfrenceMeters / (reed1TriggerTimeDifference * secondsInAMilisecond)),digitRounding)

			except:
				speedMetersPerSecond = 0

	- tried to use:

			maxSpeedToday = max(maxSpeedToday, speedMetersPerSecond)
		
		It gave an incorrect value to start with for some reason so, replaced it with:
		
			if speedMetersPerSecond >= maxSpeedToday:
				maxSpeedToday = speedMetersPerSecond

		BUT, it seems to fail at some point giving it a value much higher than the speed is.  note: using a motor and magnet running at 
		  a more or less constant speed.
		  
		Now, it is happily working away.  There was an issue with the re-write of the display that did not write the screen properly, hiding first digits
		  making it look really bad.  From the speed changing from ~ 1.100 meters per second an ~1.200 meters per second, it seems to jump up to 2.x meters 
		  per second.  when tracking, the speed now reflects this so maybe a bump in power or something from the motor.   It is very consistant now.
		
	- was not planned but came across an article on speeding up display refreshes.  The recomendation was to check if the item is the same as it was the
	  previous time and only refresh the sections requiring a refresh. Implemented it:
		- check to see if data is different != 
		- if it is, set the colour, write over old with a "." then change colour and write with the new data.  If you don't over write it first, you may
			get reminants of the old data.
		- this seems to be working.
		
	- direction tracking now seems to be fixed.  When clockwise, the time difference between reed2 and reed1 is shorter than the time difference 
		between reed1 and reed2last.  It is the reverse for ccw direction.
		
	- end of day seems to be working.  Might revisit for more efficient code later.





## v0.10 ##

   - adding screen support for real time viewing
   
   - to avoid conflict with pin 11 for the display, moved speed gp12 to 18 and dir gp11 to 21

   - changed date to yyyy-mm-dd and time to gmt+1 for winter time.

   - removed all references to km or kp/h

   - experimenting with seperating the display updates and data collection using two both cores with core 1 doing the screen updates 
       along with a delay.  This is to try and fix these issues:

           - # working on a problem where things are not updating properly, missing triggers.  This is probably due to the display updates
               being relativly slow.

           - # direction is not tracking properly, could be the same reason as the missing triggers.

	- garbage collection implemented

	- removed the code to push informaiton to a web site.
		if required, can get it back from version 0.07

	- broke the network connection routine out of the set time routine

	- added a refresh of the system clock from the NTP servers every 3 hours.

	- moving the display refresh and the ntp time update to core 1, it seems to have fixed the issue with missing data, so far.

	- direction tracking is intermittantly showing the correct direction.  Requires more thoughts.  

	- with these changes, will open v0.11.

## v0.07 ##

	- Started late in the game for version control.

	- Up to now, it has mostly been learning how micropython works and a better way to
		collect data, calculate speed, distance, direction of rotation and ensuring flags
		are set properly.

	- I still may move the calculations out of the logging, except for direction, and into
		a JavaSkript or some other method for display and storage of information.

	- This version has a working system to set the clock from an NTP server.  Reading some
		information on line, some people have had to reset the clock due to drift so may have to resync
		a couple of times a day.

	- There is also a working version to send specific data to a computer on the same network.
		Need to remember to change the flag if it is to be run.  Only here for experimenting.

	- This version we have all of the measured and calculated data being logged locally.

	- Finding a place for the direction ended up being in each of the interupt calls,
		not at the main loop where I had hoped to put it.

####
